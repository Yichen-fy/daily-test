# daily-test

##level1
根据任务要求
我需要用两个函数分别实现实现原始模式与规范模式的切换（disableRawMode和enableRawMode函数）
题干中描述的很明确，原始模式与规范模式之间只需要调整命令行的设置
查阅资料了解到，<unistd.h>库中定义了决定命令行设置的结构体以及函数，只需要通过函数，将预先设置好的符合原始模式的设置覆盖进去即可
当然，我们还需要一个结构体保存规范模式的设置，以便在程序结束后恢复规范模式
看要求：
读取用户输入，直到用户按下'q'退出。这个只需要在主循环中添加if语句即可
显示按键的ASCII值，包括控制字符。这个实现起来也很简单，只需要将读取的字符以整型的形式打印即可
实现错误处理机制。这个我最开始没有理解其意思，后来查到这些库中所包含的函数在出现错误时会返回-1
大多数执行失败的 C 库函数将设置 errno 这个全局变量来指示错误是什么. 
于是，我们通过perror() 查看 errno 全局变量并为其打印一条描述性错误消息，并退出程序，以此完成错误处理

##level2
任务2的难度几乎翻了n倍，首先我们需要为特殊按键写功能，这就要求我们删去level1中的打印，重构键盘输入
从最简单的开始，注意到“ctrl+字母”的ASCII码正是1-26，所以尝试将退出按键换为ctrl+q。
既然已知ascii码，那么我们就可以写出判断语句，从而实现ctrl+q的重构
现在问题来了，箭头键这种按键，通过查阅资料可知，它们是通过ESC[A这样的ansi转义符，前两个符号固定为'esc'，'['
而我们又得知esc的ascii码是27，即\x1b。那么我们就可以利用多层判断。先看读入的符号是不是esc，进一步判断第三个符号的种类，确定输入按键
然后，利用switch语句，分别实现各自功能，但是，case后面不能跟字符串，所以需要进行映射，为了不影响已有按键，我将这些键值从1000开始映射
当然，这也意味着读入按键的数据类型不能是char了（因为该数据类型的大小不够），得换成int
绘制屏幕，通过查阅ansi表可知，向命令行写入esc[2J可以清除屏幕，而esc[H可以将光标移动到左上角，以此完成了屏幕清除和光标定位功能
分别用两个变量表示行位置和列位置，然后通过一定的循环语句，在对应位置写入符号，就能设计一个欢迎的字样。
另外，我了解到，<sys/ioctl.h>库可以通过ioctl（）读取屏幕大小，从而方便我绘制开始界面
在此基础上，实现了对Page Up/Down、Home、End等按键的重构
然后就到了最难弄的缓冲了，这一块其实我没怎么弄懂，只是大致了解了一下用法，照葫芦画瓢来的
首先定义结构体abuf作为缓冲区，并将ABUF_INIT设为构造函数，创建一个abAppend函数用于向缓冲区加入数据
其中就需要用到realloc（）函数用于动态分配存储空间，再用memcpy将键入的数据拷贝到分配好的空间中，最后用abfree函数释放动态内存


##level3
虽然并没能完成level3的任务
但至少完成了一部分，比如读取多行文件，实现方式是创建一个名为row的指针，让它循环遍历文件每一行的内容并存入缓冲区，最后显示
再比如渲染状态栏，通过while循环确定最后一行的位置后，通过输入转义序列\x1b[7m将状态栏变为白色
随后通过一些库函数读取文件名，行数，当前行数。文件字符数大于20个时会替换为No Name
以及添加了左/右移动至行首/尾自动换行的功能，除此之外的功能，虽然有尝试过实现，但是最终都没能成功，勉强维持了上述功能
